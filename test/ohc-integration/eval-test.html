<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JTW Eval Test</title>
</head>
<body>
  <h1>JTW Eval Test</h1>
  <div id="status">Loading...</div>
  <pre id="log"></pre>
  <script type="module">
    import { OcamlWorker } from '/client/ocaml-worker.js';

    const status = document.getElementById('status');
    const logEl = document.getElementById('log');

    function log(msg) {
      logEl.textContent += msg + '\n';
      console.log(msg);
    }

    // Blessed: ?package=name.ver  → p/{name}/{ver}/findlib_index
    // Non-blessed: ?universe=HASH&package=name.ver → u/{hash}/{name}/{ver}/findlib_index
    // Legacy: ?universe=HASH (no package) → u/{hash}/findlib_index
    const params = new URLSearchParams(window.location.search);
    const universe = params.get('universe');
    const pkg = params.get('package');
    const compilerVersion = params.get('compiler') || '5.4.0';

    if (!universe && !pkg) {
      status.textContent = 'Error: ?package= or ?universe= parameter required';
      status.dataset.error = 'package or universe parameter required';
      throw new Error('package or universe parameter required');
    }

    status.textContent = 'Fetching findlib_index...';
    let indexUrl;
    if (pkg) {
      const [name, ver] = [pkg.substring(0, pkg.indexOf('.')), pkg.substring(pkg.indexOf('.') + 1)];
      if (universe) {
        indexUrl = `/jtw-output/u/${universe}/${name}/${ver}/findlib_index`;
      } else {
        indexUrl = `/jtw-output/p/${name}/${ver}/findlib_index`;
      }
    } else {
      indexUrl = `/jtw-output/u/${universe}/findlib_index`;
    }
    const { worker, stdlib_dcs, findlib_index } = await OcamlWorker.fromIndex(
      indexUrl, '/jtw-output', { timeout: 120000 });

    try {
      status.textContent = 'Initializing...';
      await worker.init({
        findlib_requires: [],
        stdlib_dcs: stdlib_dcs,
        findlib_index: findlib_index,
      });

      status.textContent = 'Ready';
      status.dataset.ready = 'true';

      // Expose eval/complete/require on window for Playwright
      window.workerEval = async (code) => {
        const result = await worker.eval(code);
        return {
          caml_ppf: result.caml_ppf || '',
          stdout: result.stdout || '',
          stderr: result.stderr || '',
        };
      };

      window.workerComplete = async (source, pos) => {
        const result = await worker.complete(source, pos);
        const entries = result.completions?.entries || [];
        return entries.map(e => e.name);
      };

    } catch (err) {
      status.textContent = 'Error: ' + err.message;
      status.dataset.error = err.message;
      log('ERROR: ' + err.message);
    }
  </script>
</body>
</html>
