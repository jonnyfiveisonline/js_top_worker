// Tutorial test definitions for all Bunzli library versions
// Each entry is a self-contained interactive tutorial

const U = {
  'fmt.0.9.0':      '9901393f978b0a6627c5eab595111f50',
  'fmt.0.10.0':     'dc92d356407d44e1eae7e39acefce214',
  'fmt.0.11.0':     '5c8d38716cee871f1a6a1f164c9171e6',
  'cmdliner.1.0.4': '1c3783a51f479ccb97503596896eb40b',
  'cmdliner.1.3.0': 'bcb1b5485952a387d9a1a626d018fc5b',
  'cmdliner.2.0.0': 'e6cf251f6257587fa235157819c1be21',
  'cmdliner.2.1.0': '146d116fd47cdde3a5912f6c3c43a06c',
  'mtime.1.3.0':    '405772d8c1d5fcfb52a34bc074e9b2bf',
  'mtime.1.4.0':    'd07582e1ae666064d4e2cf55b8f966f2',
  'mtime.2.1.0':    '427565ec9f440e77ea8cda7a5baf2f16',
  'logs.0.7.0':     '2579ce9998e74d858251a8467a2d3acc',
  'logs.0.10.0':    '1447d6620c603faabafd2a4af8180e64',
  'uucp.14.0.0':    '61994aea366afe63fbbdfbec3a6c1c17',
  'uucp.15.0.0':    '1676ff3253642b3d3380da595576d048',
  'uucp.16.0.0':    '2536abe6336b2597409378c985af206f',
  'uucp.17.0.0':    '9f478f56c02c6b75ad53e569576ac528',
  'uunf.14.0.0':    'c49889fbf46b81974819b189749084eb',
  'uunf.17.0.0':    'd41feec064e2a5ca2ca9ce644b490c35',
  'astring.0.8.5':  '77fa5901f826c06565dd83b8f758980c',
  'jsonm.1.0.2':    '331ba04a1674f61d6eb297de762940ea',
  'xmlm.1.4.0':     'de0c6b460a24c08865ced16ef6a90978',
  'ptime.1.2.0':    '0e977ea260d75026d2cdd4a7d007b2a5',
  'react.1.2.2':    '8b8f1bafe428e743bbb3e9f6a24753a5',
  'hmap.0.8.1':     '9cbc1bea29fe2a32ff73726147a24f7f',
  'gg.1.0.0':       '0c7a6cc72b0eef74ddf88e8512b418e1',
  'note.0.0.3':     '7497fed22490d2257a6fb4ac44bb1316',
  'otfm.0.4.0':     'af7a1a159d4a1c27da168df5cad06ad9',
  'vg.0.9.5':       '8a313572e25666862de0bc23fc09c53d',
  'bos.0.2.1':      '1447d6620c603faabafd2a4af8180e64',
  'fpath.0.7.3':    'b034f0f4718c8842fdec8d4ff3430b97',
  'uutf.1.0.4':     '331ba04a1674f61d6eb297de762940ea',
  'b0.0.0.6':       '3125f46428fef2c0920ae254a3678000',
};

// ── Factory: Fmt (same API across 0.9–0.11) ────────────────────────────
function fmtTutorial(version, universe) {
  return {
    name: 'Fmt', version, opam: 'fmt',
    description: 'OCaml Format pretty-printer combinators',
    universe, require: ['fmt'],
    sections: [
      { title: 'String Formatting',
        description: 'Fmt.str works like Printf.sprintf, building a string from a format string.',
        steps: [
          { code: 'Fmt.str "%d" 42;;', expect: '"42"',
            description: 'Format an integer into a string' },
          { code: 'Fmt.str "Hello, %s!" "world";;', expect: '"Hello, world!"',
            description: 'Interpolate a string value' },
          { code: 'Fmt.str "%d + %d = %d" 1 2 3;;', expect: '"1 + 2 = 3"',
            description: 'Multiple format arguments' },
          { code: 'Fmt.str "%a" Fmt.int 42;;', expect: '"42"',
            description: 'Use a typed formatter with %a' },
        ] },
      { title: 'Typed Formatters',
        description: 'Fmt provides typed formatter values (type \'a Fmt.t = Format.formatter -> \'a -> unit) for common types.',
        steps: [
          { code: 'Fmt.str "%a" Fmt.bool true;;', expect: '"true"',
            description: 'Format a boolean' },
          { code: 'Fmt.str "%a" Fmt.float 3.14;;', expect: '3.14',
            description: 'Format a float' },
          { code: 'Fmt.str "%a" Fmt.string "hi";;', expect: '"hi"',
            description: 'Format a string with the string formatter' },
        ] },
      { title: 'Collection Formatters',
        description: 'Fmt can format lists, options, pairs, and results with configurable separators.',
        steps: [
          { code: 'Fmt.str "%a" Fmt.(list int) [1; 2; 3];;', expect: '1',
            description: 'Format a list of ints (default separator)' },
          { code: 'Fmt.str "%a" Fmt.(list ~sep:comma int) [1; 2; 3];;', expect: '1, 2',
            description: 'Format a list with comma separators' },
          { code: 'Fmt.str "%a" Fmt.(list ~sep:(any " ") int) [10; 20];;', expect: '"10 20"',
            description: 'Format with space separators using Fmt.any' },
          { code: 'Fmt.str "%a" Fmt.(option int) (Some 5);;', expect: '5',
            description: 'Format an option value' },
          { code: 'Fmt.str "%a" Fmt.(option int) None;;', expect: '',
            description: 'Format None (empty output by default)' },
          { code: 'Fmt.str "%a" Fmt.(pair ~sep:comma int string) (42, "hi");;', expect: '42',
            description: 'Format a pair' },
        ] },
      { title: 'Output to stdout',
        description: 'Fmt.pr prints directly to stdout. Use @. for a newline flush.',
        steps: [
          { code: 'Fmt.pr "value: %d@." 42;;', expectStdout: 'value: 42',
            description: 'Print formatted output to stdout' },
          { code: 'Fmt.pr "%a@." Fmt.(list ~sep:sp int) [1; 2; 3];;', expectStdout: '1',
            description: 'Print a list to stdout' },
        ] },
      { title: 'Combinators',
        description: 'Higher-order combinators transform formatters.',
        steps: [
          { code: 'let pp_len = Fmt.using String.length Fmt.int;;', expect: 'Fmt.t',
            description: 'Fmt.using transforms input before formatting' },
          { code: 'Fmt.str "%a" pp_len "hello";;', expect: '"5"',
            description: 'pp_len formats the length of a string' },
          { code: 'Fmt.str "%a" (Fmt.Dump.list Fmt.int) [1; 2; 3];;', expect: '[1; 2; 3]',
            description: 'Fmt.Dump formats with OCaml syntax (brackets)' },
        ] },
    ],
  };
}

// ── Factory: Uucp (same API across 14–17, different Unicode version) ───
function uucpTutorial(version, universe, unicodeVer) {
  return {
    name: 'Uucp', version, opam: 'uucp',
    description: `Unicode character properties (Unicode ${unicodeVer})`,
    universe, require: ['uucp'],
    sections: [
      { title: 'Unicode Version',
        description: 'Each Uucp release tracks a specific Unicode standard version.',
        steps: [
          { code: 'Uucp.unicode_version;;', expect: `"${unicodeVer}"`,
            description: 'Check which Unicode version this release implements' },
        ] },
      { title: 'General Category',
        description: 'Uucp.Gc.general_category returns the Unicode General Category of a character as a polymorphic variant.',
        steps: [
          { code: 'Uucp.Gc.general_category (Uchar.of_int 0x0041);;', expect: '`Lu',
            description: "'A' (U+0041) is an uppercase letter (Lu)" },
          { code: 'Uucp.Gc.general_category (Uchar.of_int 0x0061);;', expect: '`Ll',
            description: "'a' (U+0061) is a lowercase letter (Ll)" },
          { code: 'Uucp.Gc.general_category (Uchar.of_int 0x0030);;', expect: '`Nd',
            description: "'0' (U+0030) is a decimal digit (Nd)" },
          { code: 'Uucp.Gc.general_category (Uchar.of_int 0x0020);;', expect: '`Zs',
            description: "Space (U+0020) is a space separator (Zs)" },
        ] },
      { title: 'Script Detection',
        description: 'Uucp.Script.script identifies which writing system a character belongs to.',
        steps: [
          { code: 'Uucp.Script.script (Uchar.of_int 0x03B1);;', expect: '`Grek',
            description: "Greek alpha (U+03B1) is in the Greek script" },
          { code: 'Uucp.Script.script (Uchar.of_int 0x4E16);;', expect: '`Hani',
            description: "CJK character (U+4E16) is in the Han script" },
          { code: 'Uucp.Script.script (Uchar.of_int 0x0041);;', expect: '`Latn',
            description: "'A' is in the Latin script" },
        ] },
      { title: 'Character Properties',
        description: 'Uucp provides boolean property lookups for whitespace, alphabetic characters, and more.',
        steps: [
          { code: 'Uucp.White.is_white_space (Uchar.of_int 0x0020);;', expect: 'true',
            description: 'Space is whitespace' },
          { code: 'Uucp.White.is_white_space (Uchar.of_int 0x0041);;', expect: 'false',
            description: "'A' is not whitespace" },
          { code: 'Uucp.White.is_white_space (Uchar.of_int 0x00A0);;', expect: 'true',
            description: 'Non-breaking space (U+00A0) is whitespace' },
        ] },
    ],
  };
}

// ── Factory: Uunf (same API, different Unicode version) ────────────────
function uunfTutorial(version, universe, unicodeVer) {
  return {
    name: 'Uunf', version, opam: 'uunf',
    description: `Unicode text normalization (Unicode ${unicodeVer})`,
    universe, require: ['uunf'],
    sections: [
      { title: 'Unicode Version',
        description: 'Each Uunf release implements normalization according to a specific Unicode version.',
        steps: [
          { code: 'Uunf.unicode_version;;', expect: `"${unicodeVer}"`,
            description: 'Check the Unicode version' },
        ] },
      { title: 'Normalization Forms',
        description: 'Unicode defines four normalization forms: NFC, NFD, NFKC, and NFKD. Uunf.create selects which form to use.',
        steps: [
          { code: 'let nfc = Uunf.create `NFC;;', expect: 'Uunf.t',
            description: 'Create an NFC normalizer' },
          { code: 'let nfd = Uunf.create `NFD;;', expect: 'Uunf.t',
            description: 'Create an NFD normalizer (canonical decomposition)' },
          { code: 'let nfkc = Uunf.create `NFKC;;', expect: 'Uunf.t',
            description: 'Create an NFKC normalizer (compatibility composition)' },
          { code: 'let nfkd = Uunf.create `NFKD;;', expect: 'Uunf.t',
            description: 'Create an NFKD normalizer (compatibility decomposition)' },
        ] },
      { title: 'Adding Characters',
        description: 'Feed characters to the normalizer with Uunf.add. It returns `Uchar for output characters and `Await when ready for more input.',
        steps: [
          { code: 'let n = Uunf.create `NFC;;', expect: 'Uunf.t',
            description: 'Create a fresh NFC normalizer' },
          { code: 'Uunf.add n (`Uchar (Uchar.of_int 0x0041));;', expect: '',
            description: "Add 'A' to the normalizer" },
          { code: 'Uunf.add n `End;;', expect: '',
            description: 'Signal end of input' },
        ] },
    ],
  };
}

// ── Factory: Mtime 1.x (1.3 and 1.4 share the same API) ───────────────
function mtime1_3Tutorial(version, universe) {
  // Mtime 1.3.0: no named constants (ns/ms/s), uses float conversion functions
  return {
    name: 'Mtime', version, opam: 'mtime',
    description: 'Monotonic wall-clock time for OCaml',
    universe, require: ['mtime'],
    sections: [
      { title: 'Time Span Basics',
        description: 'Mtime.Span represents monotonic time durations in nanoseconds.',
        steps: [
          { code: 'Mtime.Span.zero;;', expect: 'Mtime.span',
            description: 'The zero-length span' },
          { code: 'Mtime.Span.one;;', expect: 'Mtime.span',
            description: 'One nanosecond' },
          { code: 'Mtime.Span.max_span;;', expect: 'Mtime.span',
            description: 'The maximum representable span' },
          { code: 'Mtime.Span.of_uint64_ns 1_000_000_000L;;', expect: 'Mtime.span',
            description: 'Create a 1-second span from nanoseconds' },
        ] },
      { title: 'Span Arithmetic',
        description: 'Spans support addition, comparison, and absolute difference.',
        steps: [
          { code: 'let one_sec = Mtime.Span.of_uint64_ns 1_000_000_000L;;', expect: 'Mtime.span',
            description: 'One second' },
          { code: 'let two_sec = Mtime.Span.add one_sec one_sec;;', expect: 'Mtime.span',
            description: 'Add two spans: 1s + 1s = 2s' },
          { code: 'Mtime.Span.to_uint64_ns two_sec;;', expect: '2000000000L',
            description: '2 seconds in nanoseconds' },
          { code: 'Mtime.Span.equal Mtime.Span.zero Mtime.Span.zero;;', expect: 'true',
            description: 'Zero equals zero' },
          { code: 'Mtime.Span.compare one_sec Mtime.Span.zero;;', expect: '1',
            description: '1 second is greater than zero' },
        ] },
      { title: 'Float Conversions',
        description: 'Convert spans to floating-point representations in various units.',
        steps: [
          { code: 'Mtime.Span.to_ns one_sec;;', expect: '1000000000.',
            description: '1 second = 1e9 nanoseconds' },
          { code: 'Mtime.Span.to_ms one_sec;;', expect: '1000.',
            description: '1 second = 1000 milliseconds' },
          { code: 'Mtime.Span.to_s one_sec;;', expect: '1.',
            description: '1 second as a float' },
          { code: 'Mtime.Span.to_us one_sec;;', expect: '1000000.',
            description: '1 second = 1e6 microseconds' },
        ] },
    ],
  };
}

function mtime1_4Tutorial(version, universe) {
  // Mtime 1.4.0: has named constants (ns/ms/s) and is_shorter/is_longer
  return {
    name: 'Mtime', version, opam: 'mtime',
    description: 'Monotonic wall-clock time for OCaml',
    universe, require: ['mtime'],
    sections: [
      { title: 'Time Span Constants',
        description: 'Mtime 1.4 added named constants for common time durations.',
        steps: [
          { code: 'Mtime.Span.zero;;', expect: 'Mtime.span',
            description: 'The zero-length span' },
          { code: 'Mtime.Span.ns;;', expect: 'Mtime.span',
            description: '1 nanosecond' },
          { code: 'Mtime.Span.ms;;', expect: 'Mtime.span',
            description: '1 millisecond' },
          { code: 'Mtime.Span.s;;', expect: 'Mtime.span',
            description: '1 second' },
          { code: 'Mtime.Span.min;;', expect: 'Mtime.span',
            description: '1 minute' },
        ] },
      { title: 'Span Arithmetic',
        description: 'Spans support addition, scaling, and comparison.',
        steps: [
          { code: 'let two_sec = Mtime.Span.add Mtime.Span.s Mtime.Span.s;;', expect: 'Mtime.span',
            description: '1s + 1s = 2s' },
          { code: 'Mtime.Span.to_uint64_ns two_sec;;', expect: '2000000000L',
            description: '2 seconds in nanoseconds' },
          { code: 'Mtime.Span.compare Mtime.Span.ms Mtime.Span.s;;', expect: '-1',
            description: '1ms is less than 1s' },
          { code: 'Mtime.Span.equal Mtime.Span.zero Mtime.Span.zero;;', expect: 'true',
            description: 'Zero equals zero' },
        ] },
      { title: 'Conversions',
        description: 'Convert spans to floating-point representations in various units.',
        steps: [
          { code: 'Mtime.Span.to_ms Mtime.Span.s;;', expect: '1000.',
            description: '1 second = 1000 milliseconds' },
          { code: 'Mtime.Span.to_s Mtime.Span.s;;', expect: '1.',
            description: '1 second as a float' },
          { code: 'Mtime.Span.of_uint64_ns 500_000_000L |> Mtime.Span.to_ms;;', expect: '500.',
            description: '500ms round-trip through nanoseconds' },
        ] },
    ],
  };
}

export const TUTORIALS = {
  // ═══════════════════════════════════════════════════════════════════════
  // Fmt
  // ═══════════════════════════════════════════════════════════════════════
  'fmt.0.9.0':  fmtTutorial('0.9.0',  U['fmt.0.9.0']),
  'fmt.0.10.0': fmtTutorial('0.10.0', U['fmt.0.10.0']),
  'fmt.0.11.0': fmtTutorial('0.11.0', U['fmt.0.11.0']),

  // ═══════════════════════════════════════════════════════════════════════
  // Cmdliner
  // ═══════════════════════════════════════════════════════════════════════
  'cmdliner.1.0.4': {
    name: 'Cmdliner', version: '1.0.4', opam: 'cmdliner',
    description: 'Declarative definition of command line interfaces (v1 API)',
    universe: U['cmdliner.1.0.4'], require: ['cmdliner'],
    sections: [
      { title: 'Argument Info',
        description: 'Cmdliner.Arg.info describes command-line arguments with names, docs, and metadata.',
        steps: [
          { code: 'let verbose_info = Cmdliner.Arg.info ["v"; "verbose"] ~doc:"Be verbose";;',
            expect: 'Cmdliner.Arg.info', description: 'Create info for a --verbose/-v flag' },
          { code: 'let name_info = Cmdliner.Arg.info [] ~docv:"NAME" ~doc:"The name";;',
            expect: 'Cmdliner.Arg.info', description: 'Create info for a positional argument' },
        ] },
      { title: 'Argument Definitions',
        description: 'Arguments are built from converters + info, then lifted into terms with Arg.value.',
        steps: [
          { code: 'Cmdliner.Arg.string;;', expect: 'string Cmdliner.Arg.conv',
            description: 'Built-in string converter' },
          { code: 'Cmdliner.Arg.int;;', expect: 'int Cmdliner.Arg.conv',
            description: 'Built-in int converter' },
          { code: 'let verbose = Cmdliner.Arg.(value (flag (info ["v";"verbose"])));;',
            expect: 'bool Cmdliner.Term.t', description: 'Define a boolean flag term' },
          { code: 'let count = Cmdliner.Arg.(value (opt int 0 (info ["c";"count"])));;',
            expect: 'int Cmdliner.Term.t', description: 'Define an optional int argument with default 0' },
        ] },
      { title: 'Terms (v1 API)',
        description: 'In Cmdliner 1.0.x, Term.const and Term.($) combine argument terms into a program term.',
        steps: [
          { code: 'let greet = Cmdliner.Term.const (fun v n -> Printf.sprintf "%s%s" (if v then "HI " else "hi ") n);;',
            expect: 'Cmdliner.Term.t', description: 'A constant function lifted into a term' },
          { code: 'Cmdliner.Term.info "greet" ~doc:"A greeting program";;',
            expect: 'Cmdliner.Term.info', description: 'Term.info describes the command (v1 API)' },
          { code: 'Cmdliner.Term.eval;;', expect: 'Term.result',
            description: 'Term.eval runs a term — available in 1.0.x' },
        ] },
    ],
  },

  'cmdliner.1.3.0': {
    name: 'Cmdliner', version: '1.3.0', opam: 'cmdliner',
    description: 'Declarative definition of command line interfaces (transitional)',
    universe: U['cmdliner.1.3.0'], require: ['cmdliner'],
    sections: [
      { title: 'Argument Building',
        description: 'Cmdliner 1.3 is a transitional release supporting both the old Term API and the new Cmd API.',
        steps: [
          { code: 'let verbose = Cmdliner.Arg.(value (flag (info ["v";"verbose"] ~doc:"Be verbose")));;',
            expect: 'bool Cmdliner.Term.t', description: 'Define a verbose flag' },
          { code: 'let greeting = Cmdliner.Arg.(value (pos 0 string "world" (info [] ~docv:"NAME")));;',
            expect: 'string Cmdliner.Term.t', description: 'Define a positional name argument' },
        ] },
      { title: 'New Cmd API (introduced in 1.1+)',
        description: 'The Cmd module provides a structured way to define commands, replacing Term.info + Term.eval.',
        steps: [
          { code: 'Cmdliner.Cmd.info "hello" ~doc:"Say hello";;',
            expect: 'Cmdliner.Cmd.info', description: 'Cmd.info creates command metadata' },
          { code: 'let hello_t = Cmdliner.Term.(const (fun v n -> ()) $ verbose $ greeting);;',
            expect: 'Cmdliner.Term.t', description: 'Combine arguments with Term.const and ($)' },
          { code: 'Cmdliner.Cmd.v (Cmdliner.Cmd.info "hello") hello_t;;',
            expect: 'Cmdliner.Cmd.t', description: 'Create a command from info + term' },
        ] },
      { title: 'Backward Compatibility',
        description: 'The old Term.eval API still works in 1.3 for migration.',
        steps: [
          { code: 'Cmdliner.Term.eval;;', expect: 'Term.result',
            description: 'Term.eval is still available (deprecated but functional)' },
          { code: 'Cmdliner.Term.info "test";;', expect: 'Cmdliner.Term.info',
            description: 'Term.info still works for backward compat' },
        ] },
    ],
  },

  'cmdliner.2.0.0': {
    name: 'Cmdliner', version: '2.0.0', opam: 'cmdliner',
    description: 'Declarative definition of command line interfaces (v2 API)',
    universe: U['cmdliner.2.0.0'], require: ['cmdliner'],
    sections: [
      { title: 'Arguments',
        description: 'Arguments are defined the same way as in earlier versions.',
        steps: [
          { code: 'let verbose = Cmdliner.Arg.(value (flag (info ["v";"verbose"])));;',
            expect: 'bool Cmdliner.Term.t', description: 'A boolean flag term' },
          { code: 'let name = Cmdliner.Arg.(value (pos 0 string "world" (info [])));;',
            expect: 'string Cmdliner.Term.t', description: 'A positional string argument' },
        ] },
      { title: 'Cmd Module (v2 API)',
        description: 'In Cmdliner 2.x, Cmd replaces Term.info/Term.eval entirely.',
        steps: [
          { code: 'Cmdliner.Cmd.info "greet" ~doc:"Greet someone";;',
            expect: 'Cmdliner.Cmd.info', description: 'Create command info' },
          { code: 'let t = Cmdliner.Term.(const (fun _ _ -> ()) $ verbose $ name);;',
            expect: 'Cmdliner.Term.t', description: 'Build the term' },
          { code: 'let cmd = Cmdliner.Cmd.v (Cmdliner.Cmd.info "greet") t;;',
            expect: 'Cmdliner.Cmd.t', description: 'Package into a command' },
          { code: 'Cmdliner.Cmd.name cmd;;', expect: '"greet"',
            description: 'Extract the command name' },
        ] },
      { title: 'Removed APIs',
        description: 'Term.eval was removed in 2.0. Use Cmd.eval_value instead.',
        steps: [
          { code: 'Cmdliner.Cmd.eval_value;;', expect: 'eval_ok',
            description: 'Cmd.eval_value is the new entry point' },
        ] },
    ],
  },

  'cmdliner.2.1.0': {
    name: 'Cmdliner', version: '2.1.0', opam: 'cmdliner',
    description: 'Declarative definition of command line interfaces (v2 API)',
    universe: U['cmdliner.2.1.0'], require: ['cmdliner'],
    sections: [
      { title: 'Arguments',
        description: 'Define typed command-line arguments with converters and info.',
        steps: [
          { code: 'let verbose = Cmdliner.Arg.(value (flag (info ["v";"verbose"] ~doc:"Increase verbosity")));;',
            expect: 'bool Cmdliner.Term.t', description: 'A verbose flag' },
          { code: 'let file = Cmdliner.Arg.(required (pos 0 (some string) None (info [] ~docv:"FILE")));;',
            expect: 'string Cmdliner.Term.t', description: 'A required positional file argument' },
          { code: 'let count = Cmdliner.Arg.(value (opt int 1 (info ["n";"count"] ~doc:"Repeat count")));;',
            expect: 'int Cmdliner.Term.t', description: 'An optional integer with default' },
        ] },
      { title: 'Commands',
        description: 'Commands combine a term with metadata. Groups can nest subcommands.',
        steps: [
          { code: 'let info = Cmdliner.Cmd.info "process" ~version:"1.0" ~doc:"Process files";;',
            expect: 'Cmdliner.Cmd.info', description: 'Command info with version' },
          { code: 'let t = Cmdliner.Term.(const (fun _ _ _ -> ()) $ verbose $ file $ count);;',
            expect: 'Cmdliner.Term.t', description: 'Combine all arguments' },
          { code: 'let cmd = Cmdliner.Cmd.v info t;;',
            expect: 'Cmdliner.Cmd.t', description: 'Create the command' },
          { code: 'Cmdliner.Cmd.name cmd;;', expect: '"process"',
            description: 'Retrieve the command name' },
        ] },
      { title: 'Custom Converters',
        description: 'Arg.conv creates custom argument converters from a parser/printer pair.',
        steps: [
          { code: 'let color_parser s = match s with "red" -> Ok `Red | "blue" -> Ok `Blue | _ -> Error (`Msg "unknown color");;',
            expect: 'val color_parser', description: 'Define a parser function' },
          { code: 'let color_pp ppf c = Format.pp_print_string ppf (match c with `Red -> "red" | `Blue -> "blue");;',
            expect: 'val color_pp', description: 'Define a printer' },
          { code: 'let color_conv = Cmdliner.Arg.conv (color_parser, color_pp);;',
            expect: 'Cmdliner.Arg.conv', description: 'Build a custom converter' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Mtime
  // ═══════════════════════════════════════════════════════════════════════
  'mtime.1.3.0': mtime1_3Tutorial('1.3.0', U['mtime.1.3.0']),
  'mtime.1.4.0': mtime1_4Tutorial('1.4.0', U['mtime.1.4.0']),

  'mtime.2.1.0': {
    name: 'Mtime', version: '2.1.0', opam: 'mtime',
    description: 'Monotonic wall-clock time for OCaml',
    universe: U['mtime.2.1.0'], require: ['mtime'],
    sections: [
      { title: 'Time Span Constants',
        description: 'Mtime.Span provides named constants for common durations.',
        steps: [
          { code: 'Mtime.Span.zero;;', expect: 'Mtime.span',
            description: 'Zero-length span' },
          { code: 'Mtime.Span.s;;', expect: 'Mtime.span',
            description: '1 second' },
          { code: 'Mtime.Span.min;;', expect: 'Mtime.span',
            description: '1 minute' },
          { code: 'Mtime.Span.hour;;', expect: 'Mtime.span',
            description: '1 hour' },
        ] },
      { title: 'Span Arithmetic',
        description: 'Spans support addition, comparison, and predicate-based comparisons (new in 2.x).',
        steps: [
          { code: 'let two_sec = Mtime.Span.add Mtime.Span.s Mtime.Span.s;;', expect: 'Mtime.span',
            description: '1s + 1s' },
          { code: 'Mtime.Span.to_uint64_ns two_sec;;', expect: '2000000000L',
            description: '2 seconds in nanoseconds' },
          { code: 'Mtime.Span.is_shorter Mtime.Span.ms ~than:Mtime.Span.s;;', expect: 'true',
            description: '1ms is shorter than 1s (new in 2.x)' },
          { code: 'Mtime.Span.is_longer Mtime.Span.hour ~than:Mtime.Span.min;;', expect: 'true',
            description: '1 hour is longer than 1 minute (new in 2.x)' },
        ] },
      { title: 'New in 2.x: Float Conversions',
        description: 'Mtime 2.x adds Span.of_float_ns for creating spans from floating-point nanoseconds.',
        steps: [
          { code: 'Mtime.Span.of_float_ns 1e9;;', expect: 'Some',
            description: '1e9 ns = 1 second' },
          { code: 'Mtime.Span.of_float_ns (-1.);;', expect: 'None',
            description: 'Negative values return None' },
          { code: 'Mtime.Span.of_float_ns infinity;;', expect: 'None',
            description: 'Non-finite values return None' },
          { code: 'Mtime.Span.to_float_ns Mtime.Span.s;;', expect: '1000000000.',
            description: 'Convert 1 second to float nanoseconds' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Logs
  // ═══════════════════════════════════════════════════════════════════════
  'logs.0.7.0': {
    name: 'Logs', version: '0.7.0', opam: 'logs',
    description: 'Logging infrastructure for OCaml',
    universe: U['logs.0.7.0'], require: ['logs'],
    sections: [
      { title: 'Log Sources',
        description: 'A Logs.Src.t identifies a log source with a name and optional documentation.',
        steps: [
          { code: 'let src = Logs.Src.create "myapp" ~doc:"My application";;', expect: 'Logs.src',
            description: 'Create a named log source' },
          { code: 'Logs.Src.name src;;', expect: '"myapp"',
            description: 'Retrieve the source name' },
          { code: 'Logs.Src.doc src;;', expect: '"My application"',
            description: 'Retrieve the source documentation' },
        ] },
      { title: 'Log Levels',
        description: 'Logs has five levels: App, Error, Warning, Info, Debug. The global level controls what gets logged.',
        steps: [
          { code: 'Logs.level ();;', expect: 'option',
            description: 'Get the current global log level' },
          { code: 'Logs.set_level (Some Logs.Debug);;', expect: 'unit',
            description: 'Set the global level to Debug (most verbose)' },
          { code: 'Logs.level ();;', expect: 'Some',
            description: 'Verify the level was set' },
        ] },
      { title: 'Error Counting',
        description: 'Logs tracks error and warning counts globally.',
        steps: [
          { code: 'Logs.err_count ();;', expect: 'int',
            description: 'Count of errors logged so far' },
          { code: 'Logs.warn_count ();;', expect: 'int',
            description: 'Count of warnings logged so far' },
        ] },
    ],
  },

  'logs.0.10.0': {
    name: 'Logs', version: '0.10.0', opam: 'logs',
    description: 'Logging infrastructure for OCaml',
    universe: U['logs.0.10.0'], require: ['logs'],
    sections: [
      { title: 'Log Sources',
        description: 'Create and inspect named log sources.',
        steps: [
          { code: 'let src = Logs.Src.create "test" ~doc:"A test source";;', expect: 'Logs.src',
            description: 'Create a log source' },
          { code: 'Logs.Src.name src;;', expect: '"test"',
            description: 'Get the source name' },
          { code: 'Logs.Src.doc src;;', expect: '"A test source"',
            description: 'Get the documentation string' },
          { code: 'Logs.Src.list ();;', expect: 'Logs.src list',
            description: 'List all registered sources' },
        ] },
      { title: 'Level Management',
        description: 'Control log verbosity at the global and per-source levels.',
        steps: [
          { code: 'Logs.set_level (Some Logs.Info);;', expect: 'unit',
            description: 'Set global level to Info' },
          { code: 'Logs.level ();;', expect: 'Some',
            description: 'Check the global level' },
          { code: 'Logs.Src.set_level src (Some Logs.Debug);;', expect: 'unit',
            description: 'Override the level for a specific source' },
          { code: 'Logs.Src.level src;;', expect: 'Some',
            description: 'Check the per-source level' },
        ] },
      { title: 'Error Tracking',
        description: 'Logs maintains error and warning counters.',
        steps: [
          { code: 'Logs.err_count ();;', expect: 'int',
            description: 'Number of errors logged' },
          { code: 'Logs.warn_count ();;', expect: 'int',
            description: 'Number of warnings logged' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Uucp
  // ═══════════════════════════════════════════════════════════════════════
  'uucp.14.0.0': uucpTutorial('14.0.0', U['uucp.14.0.0'], '14.0.0'),
  'uucp.15.0.0': uucpTutorial('15.0.0', U['uucp.15.0.0'], '15.0.0'),
  'uucp.16.0.0': uucpTutorial('16.0.0', U['uucp.16.0.0'], '16.0.0'),
  'uucp.17.0.0': uucpTutorial('17.0.0', U['uucp.17.0.0'], '17.0.0'),

  // ═══════════════════════════════════════════════════════════════════════
  // Uunf
  // ═══════════════════════════════════════════════════════════════════════
  'uunf.14.0.0': uunfTutorial('14.0.0', U['uunf.14.0.0'], '14.0.0'),
  'uunf.17.0.0': uunfTutorial('17.0.0', U['uunf.17.0.0'], '17.0.0'),

  // ═══════════════════════════════════════════════════════════════════════
  // Astring
  // ═══════════════════════════════════════════════════════════════════════
  'astring.0.8.5': {
    name: 'Astring', version: '0.8.5', opam: 'astring',
    description: 'Alternative String module for OCaml',
    universe: U['astring.0.8.5'], require: ['astring'],
    sections: [
      { title: 'String Splitting',
        description: 'Astring.String provides powerful splitting functions that work with string separators.',
        steps: [
          { code: 'Astring.String.cuts ~sep:"," "a,b,c";;', expect: '["a"; "b"; "c"]',
            description: 'Split on comma' },
          { code: 'Astring.String.cuts ~sep:"::" "a::b::c";;', expect: '["a"; "b"; "c"]',
            description: 'Split on multi-char separator' },
          { code: 'Astring.String.cut ~sep:"=" "key=value";;', expect: 'Some ("key", "value")',
            description: 'Cut at first separator occurrence' },
          { code: 'Astring.String.cut ~rev:true ~sep:"." "a.b.c";;', expect: 'Some ("a.b", "c")',
            description: 'Cut at last separator with ~rev:true' },
        ] },
      { title: 'String Building',
        description: 'Concatenation and transformation functions.',
        steps: [
          { code: 'Astring.String.concat ~sep:"-" ["x"; "y"; "z"];;', expect: '"x-y-z"',
            description: 'Join strings with separator' },
          { code: 'Astring.String.concat ~sep:", " ["hello"; "world"];;', expect: '"hello, world"',
            description: 'Join with comma-space' },
        ] },
      { title: 'String Testing',
        description: 'Predicate functions for string content.',
        steps: [
          { code: 'Astring.String.is_prefix ~affix:"http" "http://example.com";;', expect: 'true',
            description: 'Check for a prefix' },
          { code: 'Astring.String.is_suffix ~affix:".ml" "main.ml";;', expect: 'true',
            description: 'Check for a suffix' },
          { code: 'Astring.String.is_prefix ~affix:"ftp" "http://example.com";;', expect: 'false',
            description: 'Prefix not found' },
          { code: 'Astring.String.find_sub ~sub:"world" "hello world";;', expect: 'Some 6',
            description: 'Find substring position' },
        ] },
      { title: 'String Trimming',
        description: 'Remove whitespace or specific characters from strings.',
        steps: [
          { code: 'Astring.String.trim "  hello  ";;', expect: '"hello"',
            description: 'Trim whitespace from both ends' },
          { code: 'Astring.String.trim ~drop:(fun c -> c = \'/\') "/path/to/";;', expect: '"path/to"',
            description: 'Trim custom characters' },
        ] },
      { title: 'Substrings',
        description: 'Astring.String.Sub provides zero-copy substring operations.',
        steps: [
          { code: 'Astring.String.Sub.(to_string (v "hello world" ~start:6));;', expect: '"world"',
            description: 'Extract a substring from position 6' },
          { code: 'Astring.String.Sub.(to_string (v "hello world" ~stop:5));;', expect: '"hello"',
            description: 'Extract first 5 characters' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Jsonm
  // ═══════════════════════════════════════════════════════════════════════
  'jsonm.1.0.2': {
    name: 'Jsonm', version: '1.0.2', opam: 'jsonm',
    description: 'Non-blocking streaming JSON codec for OCaml',
    universe: U['jsonm.1.0.2'], require: ['jsonm'],
    sections: [
      { title: 'Decoding JSON Values',
        description: 'Jsonm.decoder creates a streaming decoder. Each Jsonm.decode call returns one lexeme.',
        steps: [
          { code: 'let d = Jsonm.decoder (`String "42");;', expect: 'Jsonm.decoder',
            description: 'Create a decoder from a JSON string' },
          { code: 'Jsonm.decode d;;', expect: '`Lexeme (`Float 42.)',
            description: 'Decode the number 42 (JSON numbers are floats)' },
          { code: 'Jsonm.decode d;;', expect: '`End',
            description: 'End of input' },
        ] },
      { title: 'Decoding Strings and Booleans',
        description: 'JSON strings, booleans, and null each produce a single lexeme.',
        steps: [
          { code: 'let d2 = Jsonm.decoder (`String {|"hello"|});;', expect: 'Jsonm.decoder',
            description: 'Decode a JSON string' },
          { code: 'Jsonm.decode d2;;', expect: '`Lexeme (`String "hello")',
            description: 'String lexeme' },
          { code: 'let d3 = Jsonm.decoder (`String "true");;', expect: 'Jsonm.decoder',
            description: 'Decode a JSON boolean' },
          { code: 'Jsonm.decode d3;;', expect: '`Lexeme (`Bool true)',
            description: 'Boolean lexeme' },
          { code: 'let dn = Jsonm.decoder (`String "null");;', expect: 'Jsonm.decoder',
            description: 'Decode null' },
          { code: 'Jsonm.decode dn;;', expect: '`Lexeme `Null',
            description: 'Null lexeme' },
        ] },
      { title: 'Decoding Arrays',
        description: 'Arrays produce `As (array start) and `Ae (array end) lexemes around their elements.',
        steps: [
          { code: 'let da = Jsonm.decoder (`String "[1, 2, 3]");;', expect: 'Jsonm.decoder',
            description: 'Create decoder for a JSON array' },
          { code: 'Jsonm.decode da;;', expect: '`Lexeme `As',
            description: 'Array start' },
          { code: 'Jsonm.decode da;;', expect: '`Lexeme (`Float 1.)',
            description: 'First element' },
          { code: 'Jsonm.decode da;;', expect: '`Lexeme (`Float 2.)',
            description: 'Second element' },
        ] },
      { title: 'Encoding JSON',
        description: 'Jsonm.encoder creates an encoder that writes lexemes to a buffer.',
        steps: [
          { code: 'let buf = Buffer.create 64;;', expect: 'Buffer.t',
            description: 'Create an output buffer' },
          { code: 'let e = Jsonm.encoder (`Buffer buf);;', expect: 'Jsonm.encoder',
            description: 'Create an encoder' },
          { code: 'Jsonm.encode e (`Lexeme (`Float 42.));;', expect: '`Ok',
            description: 'Encode a number' },
          { code: 'Jsonm.encode e `End;;', expect: '`Ok',
            description: 'End encoding' },
          { code: 'Buffer.contents buf;;', expect: '42',
            description: 'The buffer contains the JSON output' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Xmlm
  // ═══════════════════════════════════════════════════════════════════════
  'xmlm.1.4.0': {
    name: 'Xmlm', version: '1.4.0', opam: 'xmlm',
    description: 'Streaming XML codec for OCaml',
    universe: U['xmlm.1.4.0'], require: ['xmlm'],
    sections: [
      { title: 'Parsing XML Input',
        description: 'Xmlm.make_input creates a streaming parser. Each Xmlm.input call returns one signal.',
        steps: [
          { code: 'let i = Xmlm.make_input (`String (0, "<root/>"));;', expect: 'Xmlm.input',
            description: 'Create an input from a string' },
          { code: 'Xmlm.input i;;', expect: '`Dtd',
            description: 'First signal is the DTD (None for no doctype)' },
          { code: 'Xmlm.input i;;', expect: '`El_start',
            description: 'Element start: <root>' },
          { code: 'Xmlm.input i;;', expect: '`El_end',
            description: 'Element end: </root> (self-closing)' },
        ] },
      { title: 'Parsing with Attributes',
        description: 'Element start signals include the tag name and attributes.',
        steps: [
          { code: 'let i2 = Xmlm.make_input (`String (0, {|<div class="main">text</div>|}));;',
            expect: 'Xmlm.input', description: 'Parse XML with attributes' },
          { code: 'Xmlm.input i2;;', expect: '`Dtd',
            description: 'DTD signal' },
          { code: 'Xmlm.input i2;;', expect: '`El_start',
            description: 'Element start with attributes' },
          { code: 'Xmlm.input i2;;', expect: '`Data "text"',
            description: 'Text content' },
          { code: 'Xmlm.input i2;;', expect: '`El_end',
            description: 'Element end' },
        ] },
      { title: 'XML Output',
        description: 'Xmlm can also write XML to a buffer.',
        steps: [
          { code: 'let buf = Buffer.create 64;;', expect: 'Buffer.t',
            description: 'Create output buffer' },
          { code: 'let o = Xmlm.make_output (`Buffer buf);;', expect: 'Xmlm.output',
            description: 'Create an XML output' },
          { code: 'Xmlm.output o (`Dtd None);;', expect: 'unit',
            description: 'Write empty DTD' },
          { code: 'Xmlm.output o (`El_start (("", "item"), []));;', expect: 'unit',
            description: 'Start <item> element' },
          { code: 'Xmlm.output o (`Data "hello");;', expect: 'unit',
            description: 'Write text content' },
          { code: 'Xmlm.output o `El_end;;', expect: 'unit',
            description: 'Close the element' },
          { code: 'Buffer.contents buf;;', expect: '<item>hello</item>',
            description: 'The output XML' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Ptime
  // ═══════════════════════════════════════════════════════════════════════
  'ptime.1.2.0': {
    name: 'Ptime', version: '1.2.0', opam: 'ptime',
    description: 'POSIX time for OCaml',
    universe: U['ptime.1.2.0'], require: ['ptime'],
    sections: [
      { title: 'The Epoch',
        description: 'Ptime.epoch represents 1970-01-01 00:00:00 UTC, the Unix epoch.',
        steps: [
          { code: 'Ptime.epoch;;', expect: 'Ptime.t',
            description: 'The epoch timestamp' },
          { code: 'Ptime.to_float_s Ptime.epoch;;', expect: '0.',
            description: 'Epoch as float seconds = 0' },
        ] },
      { title: 'Creating Timestamps',
        description: 'Ptime.of_date_time creates a timestamp from a date-time tuple.',
        steps: [
          { code: 'let t = Ptime.of_date_time ((2024, 1, 1), ((12, 0, 0), 0));;', expect: 'Some',
            description: 'January 1, 2024, noon UTC' },
          { code: 'let t = match t with Some t -> t | None -> assert false;;', expect: 'Ptime.t',
            description: 'Unwrap the option' },
          { code: 'Ptime.to_date_time t;;', expect: '(2024, 1, 1)',
            description: 'Convert back to date-time tuple' },
          { code: 'Ptime.to_rfc3339 t;;', expect: '2024-01-01',
            description: 'Format as RFC 3339 string' },
        ] },
      { title: 'Time Arithmetic',
        description: 'Add and subtract time spans from timestamps.',
        steps: [
          { code: 'let one_day = Ptime.Span.of_int_s (24 * 3600);;', expect: 'Ptime.span',
            description: 'A span of one day (86400 seconds)' },
          { code: 'let tomorrow = Ptime.add_span t one_day;;', expect: 'Some',
            description: 'Add one day to our timestamp' },
          { code: 'Ptime.to_rfc3339 (Option.get tomorrow);;', expect: '2024-01-02',
            description: 'January 2nd' },
          { code: 'Ptime.Span.to_int_s (Ptime.diff (Option.get tomorrow) t);;', expect: 'Some 86400',
            description: 'Difference is exactly 86400 seconds' },
        ] },
      { title: 'Time Spans',
        description: 'Ptime.Span represents durations in days and picoseconds.',
        steps: [
          { code: 'Ptime.Span.zero;;', expect: 'Ptime.span',
            description: 'Zero duration' },
          { code: 'Ptime.Span.of_int_s 3600;;', expect: 'Ptime.span',
            description: 'One hour in seconds' },
          { code: 'Ptime.Span.to_int_s (Ptime.Span.of_int_s 3600);;', expect: 'Some 3600',
            description: 'Round-trip: int -> span -> int' },
          { code: 'Ptime.Span.to_float_s (Ptime.Span.of_int_s 90);;', expect: '90.',
            description: '90 seconds as a float' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // React
  // ═══════════════════════════════════════════════════════════════════════
  'react.1.2.2': {
    name: 'React', version: '1.2.2', opam: 'react',
    description: 'Declarative events and signals for OCaml (FRP)',
    universe: U['react.1.2.2'], require: ['react'],
    sections: [
      { title: 'Creating Signals',
        description: 'React.S.create returns a signal and a setter function. Signals always have a current value.',
        steps: [
          { code: 'let counter, set_counter = React.S.create 0;;', expect: 'React.signal',
            description: 'Create a signal with initial value 0' },
          { code: 'React.S.value counter;;', expect: '0',
            description: 'Read the current value' },
          { code: 'set_counter 42;;', expect: 'unit',
            description: 'Update the signal value' },
          { code: 'React.S.value counter;;', expect: '42',
            description: 'The value has changed' },
        ] },
      { title: 'Derived Signals',
        description: 'React.S.map creates a signal that automatically updates when its source changes.',
        steps: [
          { code: 'let doubled = React.S.map (fun x -> x * 2) counter;;', expect: 'React.signal',
            description: 'A signal that is always 2x the counter' },
          { code: 'React.S.value doubled;;', expect: '84',
            description: '42 * 2 = 84' },
          { code: 'set_counter 10;;', expect: 'unit',
            description: 'Update the counter' },
          { code: 'React.S.value doubled;;', expect: '20',
            description: 'Doubled automatically updates: 10 * 2 = 20' },
        ] },
      { title: 'Combining Signals',
        description: 'React.S.l2 combines two signals with a function. React.S.pair creates a signal of pairs.',
        steps: [
          { code: 'let name, set_name = React.S.create "world";;', expect: 'React.signal',
            description: 'A name signal' },
          { code: 'let greeting = React.S.l2 (fun n c -> Printf.sprintf "Hello %s (count=%d)" n c) name counter;;',
            expect: 'React.signal', description: 'Combine name and counter' },
          { code: 'React.S.value greeting;;', expect: '"Hello world (count=10)"',
            description: 'The combined value' },
          { code: 'set_name "OCaml";;', expect: 'unit',
            description: 'Update the name' },
          { code: 'React.S.value greeting;;', expect: '"Hello OCaml (count=10)"',
            description: 'Greeting updates automatically' },
        ] },
      { title: 'Events',
        description: 'React.E.create returns an event and a trigger. Unlike signals, events are discrete occurrences.',
        steps: [
          { code: 'let clicks, send_click = React.E.create ();;', expect: 'React.event',
            description: 'Create a click event' },
          { code: 'let click_count = React.S.hold 0 (React.E.map (fun _ -> React.S.value counter) clicks);;',
            expect: 'React.signal', description: 'Hold the counter value at each click' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Hmap
  // ═══════════════════════════════════════════════════════════════════════
  'hmap.0.8.1': {
    name: 'Hmap', version: '0.8.1', opam: 'hmap',
    description: 'Heterogeneous value maps for OCaml',
    universe: U['hmap.0.8.1'], require: ['hmap'],
    sections: [
      { title: 'Creating Keys',
        description: 'Hmap keys are created with Key.create. Each key carries a type witness, allowing the map to hold values of different types.',
        steps: [
          { code: 'let k_int : int Hmap.key = Hmap.Key.create ();;', expect: 'Hmap.key',
            description: 'A key for int values' },
          { code: 'let k_str : string Hmap.key = Hmap.Key.create ();;', expect: 'Hmap.key',
            description: 'A key for string values' },
          { code: 'let k_list : int list Hmap.key = Hmap.Key.create ();;', expect: 'Hmap.key',
            description: 'A key for int list values' },
        ] },
      { title: 'Building Maps',
        description: 'Start from Hmap.empty and add values with Hmap.add. Each key-value pair is type-safe.',
        steps: [
          { code: 'let m = Hmap.empty;;', expect: 'Hmap.t',
            description: 'An empty heterogeneous map' },
          { code: 'Hmap.is_empty m;;', expect: 'true',
            description: 'Verify it is empty' },
          { code: 'let m = m |> Hmap.add k_int 42 |> Hmap.add k_str "hello" |> Hmap.add k_list [1;2;3];;',
            expect: 'Hmap.t', description: 'Add values of different types' },
          { code: 'Hmap.cardinal m;;', expect: '3',
            description: 'Three bindings in the map' },
        ] },
      { title: 'Querying Maps',
        description: 'Hmap.find returns an option. The return type matches the key\'s type parameter.',
        steps: [
          { code: 'Hmap.find k_int m;;', expect: 'Some 42',
            description: 'Find the int value — type-safe!' },
          { code: 'Hmap.find k_str m;;', expect: 'Some "hello"',
            description: 'Find the string value' },
          { code: 'Hmap.find k_list m;;', expect: 'Some [1; 2; 3]',
            description: 'Find the int list value' },
          { code: 'Hmap.mem k_int m;;', expect: 'true',
            description: 'Check membership' },
          { code: 'let m2 = Hmap.rem k_int m;;', expect: 'Hmap.t',
            description: 'Remove a binding' },
          { code: 'Hmap.find k_int m2;;', expect: 'None',
            description: 'Key is no longer bound' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Gg
  // ═══════════════════════════════════════════════════════════════════════
  'gg.1.0.0': {
    name: 'Gg', version: '1.0.0', opam: 'gg',
    description: 'Basic types for computer graphics in OCaml',
    universe: U['gg.1.0.0'], require: ['gg'],
    sections: [
      { title: '2D Vectors',
        description: 'Gg.V2 provides 2D vector operations. Vectors are immutable float pairs.',
        steps: [
          { code: 'let v = Gg.V2.v 3.0 4.0;;', expect: 'Gg.v2',
            description: 'Create a 2D vector (3, 4)' },
          { code: 'Gg.V2.x v;;', expect: '3.',
            description: 'X component' },
          { code: 'Gg.V2.y v;;', expect: '4.',
            description: 'Y component' },
          { code: 'Gg.V2.norm v;;', expect: '5.',
            description: 'Vector magnitude: sqrt(9 + 16) = 5' },
        ] },
      { title: 'Vector Arithmetic',
        description: 'Vectors support addition, subtraction, scalar multiplication, and dot products.',
        steps: [
          { code: 'let a = Gg.V2.v 1.0 0.0;;', expect: 'Gg.v2',
            description: 'Unit vector along x-axis' },
          { code: 'let b = Gg.V2.v 0.0 1.0;;', expect: 'Gg.v2',
            description: 'Unit vector along y-axis' },
          { code: 'Gg.V2.add a b |> Gg.V2.x;;', expect: '1.',
            description: 'Addition: (1,0) + (0,1) → x = 1' },
          { code: 'Gg.V2.dot a b;;', expect: '0.',
            description: 'Dot product of perpendicular vectors = 0' },
          { code: 'Gg.V2.smul 3.0 a |> Gg.V2.x;;', expect: '3.',
            description: 'Scalar multiply: 3 * (1,0) → x = 3' },
        ] },
      { title: '3D Vectors and Cross Product',
        description: 'Gg.V3 adds a third dimension and the cross product operation.',
        steps: [
          { code: 'let i = Gg.V3.v 1.0 0.0 0.0;;', expect: 'Gg.v3',
            description: 'X-axis unit vector' },
          { code: 'let j = Gg.V3.v 0.0 1.0 0.0;;', expect: 'Gg.v3',
            description: 'Y-axis unit vector' },
          { code: 'let k = Gg.V3.cross i j;;', expect: 'Gg.v3',
            description: 'Cross product i × j = k (z-axis)' },
          { code: 'Gg.V3.z k;;', expect: '1.',
            description: 'Z component is 1 (right-hand rule)' },
        ] },
      { title: 'Colors',
        description: 'Gg.Color represents colors in linear sRGB with alpha.',
        steps: [
          { code: 'Gg.Color.red;;', expect: 'Gg.color',
            description: 'Predefined red color' },
          { code: 'Gg.Color.r Gg.Color.red;;', expect: '1.',
            description: 'Red component = 1.0' },
          { code: 'Gg.Color.g Gg.Color.red;;', expect: '0.',
            description: 'Green component = 0.0' },
          { code: 'let c = Gg.Color.v 0.5 0.8 0.2 1.0;;', expect: 'Gg.color',
            description: 'Create a custom RGBA color' },
          { code: 'Gg.Color.a c;;', expect: '1.',
            description: 'Alpha component' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Vg
  // ═══════════════════════════════════════════════════════════════════════
  'vg.0.9.5': {
    name: 'Vg', version: '0.9.5', opam: 'vg',
    description: 'Declarative 2D vector graphics for OCaml',
    universe: U['vg.0.9.5'], require: ['vg', 'gg'],
    sections: [
      { title: 'Building Paths',
        description: 'Vg.P builds immutable path values by chaining operations on P.empty.',
        steps: [
          { code: 'let p = Vg.P.empty;;', expect: 'Vg.path',
            description: 'Start with an empty path' },
          { code: 'let p = Vg.P.empty |> Vg.P.sub (Gg.P2.v 0. 0.) |> Vg.P.line (Gg.P2.v 1. 1.);;',
            expect: 'Vg.path', description: 'A line from (0,0) to (1,1)' },
          { code: 'let circ = Vg.P.empty |> Vg.P.circle (Gg.P2.v 0.5 0.5) 0.3;;',
            expect: 'Vg.path', description: 'A circle centered at (0.5, 0.5) with radius 0.3' },
          { code: 'let rect = Vg.P.empty |> Vg.P.rect (Gg.Box2.v (Gg.P2.v 0. 0.) (Gg.Size2.v 1. 1.));;',
            expect: 'Vg.path', description: 'A unit rectangle' },
        ] },
      { title: 'Creating Images',
        description: 'Vg.I constructs images from colors, paths, and compositing operations.',
        steps: [
          { code: 'let red_fill = Vg.I.const Gg.Color.red;;', expect: 'Vg.image',
            description: 'A solid red infinite image' },
          { code: 'let red_circle = Vg.I.cut circ red_fill;;', expect: 'Vg.image',
            description: 'Cut the red fill to the circle path' },
          { code: 'let blue_rect = Vg.I.cut rect (Vg.I.const Gg.Color.blue);;', expect: 'Vg.image',
            description: 'A blue rectangle' },
        ] },
      { title: 'Compositing Images',
        description: 'Vg.I.blend composites images. I.tr applies affine transforms via Gg.M3 matrices.',
        steps: [
          { code: 'let scene = Vg.I.blend red_circle blue_rect;;', expect: 'Vg.image',
            description: 'Blend circle over rectangle' },
          { code: 'Vg.I.void;;', expect: 'Vg.image',
            description: 'The empty (transparent) image' },
          { code: 'let moved = Vg.I.move (Gg.V2.v 0.5 0.5) red_circle;;', expect: 'Vg.image',
            description: 'Translate the circle by (0.5, 0.5)' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Note
  // ═══════════════════════════════════════════════════════════════════════
  'note.0.0.3': {
    name: 'Note', version: '0.0.3', opam: 'note',
    description: 'Declarative events and signals for OCaml',
    universe: U['note.0.0.3'], require: ['note'],
    sections: [
      { title: 'Constant Signals',
        description: 'Note.S.const creates a signal with a fixed value. Signals always have a current value.',
        steps: [
          { code: 'let s = Note.S.const 42;;', expect: 'Note.signal',
            description: 'A constant signal with value 42' },
          { code: 'Note.S.value s;;', expect: '42',
            description: 'Read the signal value' },
        ] },
      { title: 'Mutable Signals',
        description: 'Note.S.create returns a signal and a setter function for updating the value.',
        steps: [
          { code: 'let counter, set_counter = Note.S.create 0;;', expect: 'Note.signal',
            description: 'Create a mutable signal starting at 0' },
          { code: 'Note.S.value counter;;', expect: '0',
            description: 'Initial value' },
          { code: 'set_counter 10;;', expect: 'unit',
            description: 'Update the value to 10' },
          { code: 'Note.S.value counter;;', expect: '10',
            description: 'Value has changed' },
        ] },
      { title: 'Signal Transformations',
        description: 'Note.S.map and Note.S.l2 derive new signals from existing ones.',
        steps: [
          { code: 'let doubled = Note.S.map (( * ) 2) counter;;', expect: 'Note.signal',
            description: 'A derived signal: always 2x the counter' },
          { code: 'Note.S.value doubled;;', expect: '20',
            description: '10 * 2 = 20' },
          { code: 'let label = Note.S.map (fun n -> Printf.sprintf "count=%d" n) counter;;',
            expect: 'Note.signal', description: 'Map counter to a string label' },
          { code: 'Note.S.value label;;', expect: '"count=10"',
            description: 'Label reflects the current counter value' },
          { code: 'let sum = Note.S.l2 ( + ) counter doubled;;', expect: 'Note.signal',
            description: 'Combine two signals with l2' },
          { code: 'Note.S.value sum;;', expect: '30',
            description: '10 + 20 = 30' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Otfm
  // ═══════════════════════════════════════════════════════════════════════
  'otfm.0.4.0': {
    name: 'Otfm', version: '0.4.0', opam: 'otfm',
    description: 'OpenType font decoder for OCaml',
    universe: U['otfm.0.4.0'], require: ['otfm'],
    sections: [
      { title: 'Decoder Creation',
        description: 'Otfm.decoder creates a decoder from font byte data. Most operations require valid font data.',
        steps: [
          { code: 'Otfm.decoder;;', expect: '-> Otfm.decoder',
            description: 'The decoder constructor (takes a `String source)' },
          { code: 'let d = Otfm.decoder (`String "");;', expect: 'Otfm.decoder',
            description: 'Create a decoder (with empty data for exploration)' },
        ] },
      { title: 'Querying Font Data',
        description: 'With valid font data, you can query tables, glyph counts, and PostScript names.',
        steps: [
          { code: 'Otfm.flavour d;;', expect: 'Error',
            description: 'Flavour fails on empty data (expected)' },
          { code: 'Otfm.postscript_name d;;', expect: '',
            description: 'PostScript name query (fails gracefully on empty data)' },
          { code: 'Otfm.glyph_count d;;', expect: '',
            description: 'Glyph count query' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Fpath
  // ═══════════════════════════════════════════════════════════════════════
  'fpath.0.7.3': {
    name: 'Fpath', version: '0.7.3', opam: 'fpath',
    description: 'File system paths for OCaml',
    universe: U['fpath.0.7.3'], require: ['fpath'],
    sections: [
      { title: 'Creating Paths',
        description: 'Fpath.v creates a path from a string. Paths are validated on creation.',
        steps: [
          { code: 'Fpath.v "/usr/local/bin";;', expect: 'Fpath.t',
            description: 'Create an absolute path' },
          { code: 'Fpath.v "/usr/local/bin" |> Fpath.to_string;;', expect: '"/usr/local/bin"',
            description: 'Convert back to string' },
          { code: 'Fpath.v "src/main.ml";;', expect: 'Fpath.t',
            description: 'A relative path' },
        ] },
      { title: 'Path Composition',
        description: 'Fpath.(/) appends a segment. Paths compose naturally.',
        steps: [
          { code: 'Fpath.(v "/usr" / "local" / "bin") |> Fpath.to_string;;', expect: '"/usr/local/bin"',
            description: 'Build paths by appending segments' },
          { code: 'Fpath.(v "src" / "lib" / "main.ml") |> Fpath.to_string;;', expect: '"src/lib/main.ml"',
            description: 'Relative path composition' },
        ] },
      { title: 'Path Components',
        description: 'Extract parts of a path: parent directory, basename, filename.',
        steps: [
          { code: 'Fpath.v "/usr/local/bin" |> Fpath.parent |> Fpath.to_string;;', expect: '"/usr/local/"',
            description: 'Parent directory' },
          { code: 'Fpath.v "/usr/local/bin" |> Fpath.basename;;', expect: '"bin"',
            description: 'Basename (last segment)' },
          { code: 'Fpath.v "/usr/local/bin" |> Fpath.filename;;', expect: '"bin"',
            description: 'Filename (last non-empty segment)' },
          { code: 'Fpath.v "/a/b/" |> Fpath.basename;;', expect: '"b"',
            description: 'Basename of a directory path' },
          { code: 'Fpath.segs (Fpath.v "/a/b/c");;', expect: '[""; "a"; "b"; "c"]',
            description: 'All segments (empty first = absolute)' },
        ] },
      { title: 'File Extensions',
        description: 'Query and manipulate file extensions.',
        steps: [
          { code: 'Fpath.has_ext ".ml" (Fpath.v "main.ml");;', expect: 'true',
            description: 'Check for .ml extension' },
          { code: 'Fpath.get_ext (Fpath.v "archive.tar.gz");;', expect: '".gz"',
            description: 'Get the last extension' },
          { code: 'Fpath.get_ext ~multi:true (Fpath.v "archive.tar.gz");;', expect: '".tar.gz"',
            description: 'Get the full multi-extension' },
          { code: 'Fpath.rem_ext (Fpath.v "main.ml") |> Fpath.to_string;;', expect: '"main"',
            description: 'Remove the extension' },
        ] },
      { title: 'Path Properties',
        description: 'Test whether paths are absolute, relative, file paths, or directory paths.',
        steps: [
          { code: 'Fpath.is_abs (Fpath.v "/usr/bin");;', expect: 'true',
            description: 'Absolute path check' },
          { code: 'Fpath.is_rel (Fpath.v "src/main.ml");;', expect: 'true',
            description: 'Relative path check' },
          { code: 'Fpath.is_dir_path (Fpath.v "/usr/bin/");;', expect: 'true',
            description: 'Directory path (ends with /)' },
          { code: 'Fpath.is_file_path (Fpath.v "/usr/bin");;', expect: 'true',
            description: 'File path (does not end with /)' },
          { code: 'Fpath.normalize (Fpath.v "/a/b/../c") |> Fpath.to_string;;', expect: '"/a/c"',
            description: 'Normalize resolves .. components' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Uutf
  // ═══════════════════════════════════════════════════════════════════════
  'uutf.1.0.4': {
    name: 'Uutf', version: '1.0.4', opam: 'uutf',
    description: 'Non-blocking streaming Unicode codec for OCaml',
    universe: U['uutf.1.0.4'], require: ['uutf'],
    sections: [
      { title: 'UTF-8 Decoding',
        description: 'Uutf.decoder creates a streaming decoder. Each Uutf.decode call returns one character or a signal.',
        steps: [
          { code: 'let d = Uutf.decoder ~encoding:`UTF_8 (`String "ABC");;', expect: 'Uutf.decoder',
            description: 'Create a UTF-8 decoder for "ABC"' },
          { code: 'Uutf.decode d;;', expect: '`Uchar',
            description: 'Decode first character: A' },
          { code: 'Uutf.decode d;;', expect: '`Uchar',
            description: 'Decode second character: B' },
          { code: 'Uutf.decode d;;', expect: '`Uchar',
            description: 'Decode third character: C' },
          { code: 'Uutf.decode d;;', expect: '`End',
            description: 'End of input' },
        ] },
      { title: 'Multi-byte Characters',
        description: 'UTF-8 encodes non-ASCII characters in multiple bytes. Uutf handles this transparently.',
        steps: [
          { code: 'let d2 = Uutf.decoder ~encoding:`UTF_8 (`String "caf\\xC3\\xA9");;',
            expect: 'Uutf.decoder', description: 'Decode "cafe" with e-acute (U+00E9)' },
          { code: 'Uutf.decode d2;;', expect: '`Uchar',
            description: 'c' },
          { code: 'Uutf.decode d2;;', expect: '`Uchar',
            description: 'a' },
          { code: 'Uutf.decode d2;;', expect: '`Uchar',
            description: 'f' },
          { code: 'Uutf.decode d2;;', expect: '`Uchar',
            description: 'e-acute (U+00E9, decoded from 2 bytes)' },
        ] },
      { title: 'UTF-8 Encoding',
        description: 'Uutf.encoder writes Unicode characters to a buffer in a specified encoding.',
        steps: [
          { code: 'let buf = Buffer.create 16;;', expect: 'Buffer.t',
            description: 'Create an output buffer' },
          { code: 'let e = Uutf.encoder `UTF_8 (`Buffer buf);;', expect: 'Uutf.encoder',
            description: 'Create a UTF-8 encoder' },
          { code: 'Uutf.encode e (`Uchar (Uchar.of_int 0x41));;', expect: '`Ok',
            description: "Encode 'A'" },
          { code: 'Uutf.encode e (`Uchar (Uchar.of_int 0xE9));;', expect: '`Ok',
            description: "Encode e-acute" },
          { code: 'Uutf.encode e `End;;', expect: '`Ok',
            description: 'Flush the encoder' },
          { code: 'Buffer.length buf;;', expect: '3',
            description: "A (1 byte) + e-acute (2 bytes) = 3 bytes" },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // B0
  // ═══════════════════════════════════════════════════════════════════════
  'b0.0.0.6': {
    name: 'B0', version: '0.0.6', opam: 'b0',
    description: 'Software construction and deployment kit',
    universe: U['b0.0.0.6'], require: ['b0.std'],
    sections: [
      { title: 'File Paths (B0_std.Fpath)',
        description: 'B0_std provides its own Fpath module for file path manipulation.',
        steps: [
          { code: 'B0_std.Fpath.v "/usr/bin";;', expect: 'B0_std.Fpath.t',
            description: 'Create a path' },
          { code: 'B0_std.Fpath.(v "/usr" / "local" / "bin") |> B0_std.Fpath.to_string;;',
            expect: '"/usr/local/bin"', description: 'Path composition with (/)' },
          { code: 'B0_std.Fpath.basename (B0_std.Fpath.v "/usr/local/bin");;', expect: '"bin"',
            description: 'Get the basename' },
          { code: 'B0_std.Fpath.parent (B0_std.Fpath.v "/usr/local/bin") |> B0_std.Fpath.to_string;;',
            expect: '"/usr/local/"', description: 'Get parent directory' },
        ] },
      { title: 'Command Lines (B0_std.Cmd)',
        description: 'B0_std.Cmd builds command-line invocations declaratively.',
        steps: [
          { code: 'let cmd = B0_std.Cmd.(tool "ocamlfind" % "query" % "-format" % "%d" % "fmt");;',
            expect: 'B0_std.Cmd.t', description: 'Build a command line' },
          { code: 'B0_std.Cmd.to_list cmd;;', expect: '["ocamlfind"',
            description: 'Convert to a list of strings' },
          { code: 'B0_std.Cmd.is_empty B0_std.Cmd.empty;;', expect: 'true',
            description: 'Check for empty command' },
        ] },
    ],
  },

  // ═══════════════════════════════════════════════════════════════════════
  // Bos
  // ═══════════════════════════════════════════════════════════════════════
  'bos.0.2.1': {
    name: 'Bos', version: '0.2.1', opam: 'bos',
    description: 'Basic OS interaction for OCaml',
    universe: U['bos.0.2.1'], require: ['bos'],
    sections: [
      { title: 'Command Construction',
        description: 'Bos.Cmd builds shell commands declaratively with type-safe combinators.',
        steps: [
          { code: 'let cmd = Bos.Cmd.(v "echo" % "hello" % "world");;', expect: 'Bos.Cmd.t',
            description: 'Build: echo hello world' },
          { code: 'Bos.Cmd.to_string cmd;;', expect: 'echo',
            description: 'Convert to shell string' },
          { code: 'Bos.Cmd.to_list cmd;;', expect: '["echo"; "hello"; "world"]',
            description: 'Convert to argument list' },
        ] },
      { title: 'Command Combinators',
        description: 'Commands support appending, conditional inclusion, and inspection.',
        steps: [
          { code: 'let base = Bos.Cmd.(v "gcc" % "-O2");;', expect: 'Bos.Cmd.t',
            description: 'Base compiler command' },
          { code: 'let full = Bos.Cmd.(base % "-o" % "main" %% v "main.c");;', expect: 'Bos.Cmd.t',
            description: 'Append arguments and a sub-command' },
          { code: 'Bos.Cmd.to_list full;;', expect: '["gcc"',
            description: 'Full argument list' },
          { code: 'Bos.Cmd.line_tool full;;', expect: 'Some "gcc"',
            description: 'Extract the tool name' },
          { code: 'Bos.Cmd.is_empty Bos.Cmd.empty;;', expect: 'true',
            description: 'Empty command check' },
        ] },
      { title: 'Conditional Arguments',
        description: 'Bos.Cmd.on conditionally includes arguments.',
        steps: [
          { code: 'let debug = true;;', expect: 'true',
            description: 'A debug flag' },
          { code: 'Bos.Cmd.(v "gcc" %% on debug (v "-g") % "main.c") |> Bos.Cmd.to_list;;',
            expect: '["gcc"; "-g"; "main.c"]', description: 'Debug flag is included when true' },
          { code: 'Bos.Cmd.(v "gcc" %% on false (v "-g") % "main.c") |> Bos.Cmd.to_list;;',
            expect: '["gcc"; "main.c"]', description: 'Debug flag is omitted when false' },
        ] },
    ],
  },
};
