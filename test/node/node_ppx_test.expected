=== Node.js PPX Tests ===

node_ppx_test.js: [INFO] init()
Initializing findlib
Parsed uri: lib/sexplib0/META
Reading library: sexplib0
Number of children: 0
Parsed uri: lib/ocaml_intrinsics_kernel/META
Reading library: ocaml_intrinsics_kernel
Number of children: 0
Parsed uri: lib/ocaml/stdlib/META
Reading library: stdlib
Number of children: 0
Parsed uri: lib/base/META
Reading library: base
Number of children: 3
Found child: base_internalhash_types
Reading library: base.base_internalhash_types
Number of children: 0
Found child: md5
Reading library: base.md5
Number of children: 0
Found child: shadow_stdlib
Reading library: base.shadow_stdlib
Number of children: 0
node_ppx_test.js: [INFO] Adding toplevel modules for dynamic cmis from lib/ocaml/
node_ppx_test.js: [INFO]   toplevel modules: CamlinternalFormat, CamlinternalLazy, CamlinternalFormatBasics, CamlinternalMod, Std_exit, Stdlib, CamlinternalOO
node_ppx_test.js: [INFO] init() finished
node_ppx_test.js: [INFO] setup() for env default...
node_ppx_test.js: [INFO] Fetching stdlib__Format.cmi

node_ppx_test.js: [INFO] Fetching stdlib__Sys.cmi

error while evaluating #enable "pretty";;
error while evaluating #disable "shortvar";;
node_ppx_test.js: [INFO] Setup complete
node_ppx_test.js: [INFO] setup() finished for env default
--- Section 1: ppx_deriving Transformation ---
File "_none_", line 1:
Error: Unbound module Ppx_deriving_runtime
[PASS] deriving_show_type: type defined with [@@deriving show]
[PASS] deriving_show_no_pp: pp_color not available (runtime missing)

File "_none_", line 1:
Error: Unbound module Ppx_deriving_runtime
[PASS] deriving_eq_type: type defined with [@@deriving eq]

--- Section 2: Unknown Deriver Error ---

Line 1, characters 29-40:
Error: Cannot locate deriver nonexistent
[PASS] unknown_deriver_error: # type foo = A | B [@@deriving nonexistent];;

--- Section 3: Basic Code Through PPX Pipeline ---
[PASS] basic_arithmetic: # let x = 1 + 2;;
  val x : int = 3
[PASS] plain_record: # type point = { x: int; y: int };;
  type point = { x : int; y : int; }
[PASS] record_value: # let p = { x = 10; y = 20 };;
  val p : point = {x = 10; y = 20}
[PASS] recursive_fn: # let rec fib n = if n <= 1 then n else fib (n-1) + fib (n-2);;
  val fib : int -> int = <fun>
[PASS] fib_result: # fib 10;;
  - : int = 55

--- Section 4: Attributes Pass Through ---
[PASS] inline_attr: # let[@inline] double x = x + x;;
  val double : int -> int = <fun>
[PASS] warning_attr: # let[@warning "-32"] unused_fn () = ();;
  val unused_fn : unit -> unit = <fun>

--- Section 5: Module and Functor Support ---
[PASS] module_def: # module M = struct let x = 42 end;;
  module M : sig val x : int end
[PASS] module_access: # M.x;;
  - : int = 42
[PASS] module_type: # module type S = sig val x : int end;;
  module type S = sig val x : int end
[PASS] functor_def: # module F (X : S) = struct let y = X.x + 1 end;;
  module F : (X : S) -> sig val y : int end

=== Results: 15/15 tests passed ===
SUCCESS: All PPX tests passed!
